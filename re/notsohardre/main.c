#include <stdio.h>

#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))

char S[256];
char key[] = "HATSISTHEBEST";
unsigned char correct[44][16] = {{0x41,0x58,0x8d,0x5d,0x68,0x18,0xa2,0xa6,0x7b,0x88,0x32,0x30,0x76,0x34,0x52,0xf6},{0x1c,0x84,0xd3,0x70,0x6a,0xcd,0x2d,0x59,0xec,0x6b,0x68,0x79,0x17,0x23,0xa0,0x11},{0xd4,0x33,0x96,0xb6,0x9b,0x7,0x7c,0x6a,0xbf,0xbc,0x9c,0xc0,0xa1,0x74,0x7c,0x29},{0x40,0xaf,0x92,0x1,0x55,0x7d,0xb9,0xc7,0x92,0x37,0xda,0x41,0xcc,0xbf,0x23,0x45},{0xd5,0xf6,0x28,0x78,0xdc,0x36,0x9e,0x93,0x61,0x4f,0xe0,0xd6,0xc2,0x25,0x72,0x71},{0xe,0x74,0xcd,0x43,0xcf,0xc5,0xd4,0x8d,0x27,0x2f,0x37,0x16,0xbb,0xb8,0x99,0xc8},{0x4,0x72,0x99,0xd1,0xa9,0x5,0xb3,0x4b,0x8a,0x68,0x9b,0x0,0x91,0xf9,0xbf,0x8a},{0x1a,0x83,0x4d,0x31,0xcb,0xda,0x48,0x19,0x8a,0xe3,0x34,0x81,0x19,0x46,0x0,0x7f},{0x3b,0x4,0xda,0x6a,0xb7,0xaa,0xda,0xff,0x87,0x6b,0x3f,0xbc,0xe2,0xd3,0xb7,0x7e},{0xb0,0x4e,0x18,0x98,0xe3,0x17,0x8f,0x2b,0x82,0xdb,0x52,0x7d,0x96,0xc7,0xd2,0x85},{0x8e,0xbb,0xa4,0x4a,0x8e,0x48,0xc6,0x56,0xfc,0x8d,0x86,0xd,0xcb,0x86,0xb0,0xa6},{0xf,0x9,0xe1,0x64,0x22,0x35,0x61,0xff,0x4a,0x4e,0xa1,0x29,0x72,0xbf,0x7a,0x39},{0xa5,0xac,0x79,0x4d,0xfe,0x92,0xaa,0x80,0x57,0x1e,0xa5,0xd7,0x3f,0xd3,0xa6,0xa0},{0xf3,0xfc,0x70,0xf0,0x4a,0x7e,0x1e,0x49,0xf3,0x44,0xb1,0x37,0x1f,0xc,0x99,0x36},{0x43,0x49,0x12,0x44,0xd,0xf1,0x42,0xe,0x60,0x56,0x58,0xcf,0x50,0x8a,0xd8,0xb5},{0x89,0x5e,0x7d,0x8f,0x4b,0xbf,0x7c,0x59,0xff,0x50,0x46,0x1b,0xb0,0x55,0x98,0xf0},{0xa4,0x8d,0xa5,0xfb,0x8f,0x24,0x1f,0x94,0x29,0xe3,0x40,0xf3,0xb2,0xfd,0x7c,0xa1},{0xdb,0xe9,0xf,0xf7,0x58,0x7,0x4a,0x9a,0x3d,0xb1,0x96,0x6c,0x44,0x15,0xc8,0x17},{0x4e,0xbe,0xa4,0x96,0xd1,0x59,0xe3,0x67,0x92,0xc6,0x7c,0xd9,0x3a,0xa0,0xd3,0xfd},{0x3e,0x74,0x54,0x6a,0x64,0x36,0xac,0x83,0x9d,0x37,0xdc,0x84,0x6a,0xd7,0x28,0xf},{0xf6,0x1f,0x3a,0x5b,0x7b,0x78,0x6e,0xdf,0xd3,0x8a,0x1e,0xf1,0xa1,0xe,0xa0,0x7},{0xae,0x18,0x2a,0xce,0x1,0x98,0xfa,0x29,0xd1,0x80,0xe9,0xe4,0xf5,0xf9,0x9f,0x9b},{0x44,0xe2,0x55,0x3f,0xf8,0x90,0x1c,0x8,0xa7,0xf1,0x93,0x29,0x5e,0x88,0x16,0xd2},{0xf1,0xbf,0xd8,0x58,0xdc,0xf6,0xed,0xb6,0x19,0x7,0x2d,0xa4,0x89,0x6b,0x9,0x62},{0xd4,0x63,0x3e,0xe4,0x7c,0x8c,0xc2,0xf3,0xba,0x8,0xb0,0x81,0x62,0xdd,0xe6,0xda},{0x45,0x1e,0xa8,0x17,0x65,0x3b,0x2f,0x77,0x66,0xfd,0x6c,0x4b,0xc,0xf3,0xe5,0x54},{0xd7,0x0,0xc0,0xae,0xf3,0x13,0x79,0x6d,0x96,0x17,0xa5,0x67,0x1b,0x19,0x1a,0x4f},{0xe2,0x40,0x83,0xcf,0x5e,0xe5,0x82,0xfc,0x65,0x47,0x39,0xda,0xbd,0x20,0xd3,0xba},{0x89,0xab,0x22,0x12,0x78,0xa2,0x19,0x10,0xaa,0x97,0x7e,0xab,0xb1,0x97,0xd,0xf4},{0xdf,0xed,0xe7,0x53,0x5f,0x43,0xc4,0xf,0xa6,0xf2,0xcc,0x7,0xa,0xd5,0xa3,0xe7},{0xed,0x65,0x11,0x41,0x79,0xfc,0x45,0x2,0x1b,0xd5,0x73,0x73,0x37,0x13,0xc5,0xd6},{0x4b,0xcd,0x14,0x72,0xbb,0x3d,0x4f,0x1d,0x51,0x20,0x25,0x85,0x4a,0xd8,0xb5,0x5d},{0x2,0x21,0xa5,0x3e,0xc7,0xd2,0x27,0x25,0xe3,0xf8,0xa1,0x62,0xf9,0x27,0x14,0x2a},{0xc2,0x9,0xeb,0xb4,0x51,0xd9,0x90,0x39,0x43,0xab,0x5b,0xf3,0x84,0x68,0x7e,0xe5},{0xaa,0x8c,0xd6,0x88,0x4d,0x91,0xfe,0x24,0x99,0x58,0x81,0x16,0xea,0xb9,0xcb,0x3f},{0x2d,0x37,0x65,0x76,0x92,0x42,0xcf,0x64,0xb7,0xd8,0x23,0x47,0x89,0xe9,0x66,0xad},{0x23,0x2f,0x24,0xef,0x70,0xcf,0x56,0x4,0xdf,0xe0,0xfe,0xe8,0x2e,0x24,0xc2,0x9b},{0xa0,0x7a,0x5a,0x38,0xac,0xbb,0x8b,0xea,0x17,0xe9,0x17,0xd7,0xb2,0x47,0x9e,0x15},{0x5e,0x46,0xd,0x47,0x1e,0x8,0xa0,0xf4,0x76,0xd1,0xc1,0xd2,0x77,0x81,0x85,0x1},{0x72,0xd7,0xaf,0x35,0xce,0x70,0xd8,0xd7,0x38,0x3b,0xe1,0xda,0x3b,0x2,0x4a,0x77},{0xec,0x17,0xed,0xa2,0x4c,0x12,0x40,0xf4,0x64,0x11,0xe4,0xb6,0xb6,0xe5,0x8e,0x84},{0x89,0x5e,0xf0,0x92,0x56,0x69,0xfa,0x76,0xbc,0xb9,0xf4,0x1e,0xb,0x8,0xe1,0xbd},{0xad,0x54,0x2c,0x58,0x45,0x5e,0xdd,0x4a,0x65,0xd0,0xfa,0xc9,0x7d,0xe1,0x2f,0x23},{0x9,0x1d,0x37,0x59,0x73,0x75,0xfc,0x63,0x96,0x91,0xeb,0x24,0xd4,0xe0,0x7e,0xee}};

unsigned char prga_i = 0, prga_j = 0;

void ksa() {
    for (int i = 0; i < 256; ++i) {
        S[i] = i;
    }
    unsigned char j = 0;
    for (int i = 0; i < 256; ++i) {
        j += S[i] + key[i % sizeof(key)];
        char tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
    }
}

char prga() {
    prga_i++; prga_j++;
    char tmp = S[prga_i];
    S[prga_i] = S[prga_j];
    S[prga_j] = tmp;
    return S[prga_i] + S[prga_j];
}

void encrypt (unsigned int v[2], unsigned int k[4]) {
    unsigned int v0=v[0], v1=v[1], sum=0, i;           /* set up */
    unsigned int delta=0x9E3779B9;                     /* a key schedule constant */
    unsigned int k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i<32; i++) {                         /* basic cycle start */
        sum += delta;
        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}

void md5(unsigned char *initial_msg, size_t initial_len, unsigned int out[4]) {
 
    // Message (to prepare)
    unsigned char *msg = NULL;
 
    // Note: All variables are unsigned 32 bit and wrap modulo 2^32 when calculating
 
    // r specifies the per-round shift amounts
 
    unsigned int r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                    5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};

    // Use binary integer part of the sines of integers (in radians) as constants// Initialize variables:
    unsigned int k[] = {
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
        0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
        0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
        0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
        0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
        0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
        0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
        0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};
 
    unsigned int h0 = 0x67452301;
    unsigned int h1 = 0xefcdab89;
    unsigned int h2 = 0x98badcfe;
    unsigned int h3 = 0x10325476;
 
    // Pre-processing: adding a single 1 bit
    //append "1" bit to message    
    /* Notice: the input bytes are considered as bits strings,
       where the first bit is the most significant bit of the byte.[37] */
 
    // Pre-processing: padding with zeros
    //append "0" bit until message length in bit ≡ 448 (mod 512)
    //append length mod (2 pow 64) to message
 
    int new_len = ((((initial_len + 8) / 64) + 1) * 64) - 8;
 
    msg = calloc(new_len + 64, 1); // also appends "0" bits 
                                   // (we alloc also 64 extra bytes...)
    memcpy(msg, initial_msg, initial_len);
    msg[initial_len] = 128; // write the "1" bit
 
    unsigned int bits_len = 8*initial_len; // note, we append the len
    memcpy(msg + new_len, &bits_len, 4);           // in bits at the end of the buffer
 
    // Process the message in successive 512-bit chunks:
    //for each 512-bit chunk of message:
    int offset;
    for(offset=0; offset<new_len; offset += (512/8)) {
 
        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15
        unsigned int *w = (unsigned int *) (msg + offset);
 
        // Initialize hash value for this chunk:
        unsigned int a = h0;
        unsigned int b = h1;
        unsigned int c = h2;
        unsigned int d = h3;
 
        // Main loop:
        unsigned int i;
        for(i = 0; i<64; i++) { 
            unsigned int f, g;
 
             if (i < 16) {
                f = (b & c) | ((~b) & d);
                g = i;
            } else if (i < 32) {
                f = (d & b) | ((~d) & c);
                g = (5*i + 1) % 16;
            } else if (i < 48) {
                f = b ^ c ^ d;
                g = (3*i + 5) % 16;          
            } else {
                f = c ^ (b | (~d));
                g = (7*i) % 16;
            }

            unsigned int temp = d;
            d = c;
            c = b;
            b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
            a = temp;
        }
 
        // Add this chunk's hash to result so far:
 
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
    }

    out[0] = h0;
    out[1] = h1;
    out[2] = h2;
    out[3] = h3;
 
    // cleanup
    free(msg);
}

char blah(char c, char out[16]) {
    c *= 67;
    c *= 11;
    c += 33;
    
    unsigned int v[2];
    v[0] = (c << 6) + (prga() << 4) + (prga() << 2) + prga();
    v[1] = (prga() << 6) + (prga() << 4) + (prga() << 2) + c;

    unsigned int k[4];
    k[0] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[1] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[2] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();
    k[3] = (prga() << 6) + (prga() << 4) + (prga() << 2) + prga();

    encrypt(v, k);

    unsigned int o[4];
    md5((char*) v, 8, o);

    memcpy(out, o, 16);
}

int main() {
    ksa();

    printf("Enter the password: ");
    char input[256];
    scanf("%255s", input);

    if (strlen(input) != 44) {
        puts("WRONG");
        return 0;
    }
    
    // printf("{");
    for (int i = 0; i < strlen(input); ++i) {
        char hash[16];
        blah(input[i], hash);

        // if (i > 0) printf(",");
        // printf("{");
        // for (int j = 0; j < 16; ++j) {
        //     if (j > 0) printf(",");
        //     printf("0x%hhx", hash[j]);
        // }
        // printf("}");
        if (memcmp(hash, correct[i], 16) != 0) {
            puts("WRONG");
            return 0;
        }
    }
    // puts("}");

    puts("YOU GOT IT!");

    return 0;
}